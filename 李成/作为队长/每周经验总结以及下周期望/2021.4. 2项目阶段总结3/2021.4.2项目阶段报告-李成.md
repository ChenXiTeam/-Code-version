# 2021.4.2项目阶段报告
## 提要
- 主要解释了论文中的部分内容。

## 本周总结
1、主要是阅读了《Comparison and Evaluation of Clone Detection Tools》这篇论文

## 论文内容

### section 1

在文章的第一部分主要是分析了代码克隆的一些应用场景以及检测代码克隆的实际意义。

主要是因为代码克隆这种情况普遍存在并且普遍缺少相关的文档记录，所以对于被克隆部分的在需要修改的时候往往耗费颇多，于是代码克隆的检测就显得很有必要。

### section 2

主要介绍了几种克隆检测的方式
- 文本比较
	为了提高性能，使用字符串的哈希函数对行进行分区。只比较同一分区中的行。结果显示为点图，每个点表示一对克隆线。
	在这些点图中，克隆可以被发现为特定的模式视觉上。连续的在点图中，直线可以自动地总结成更大的克隆序列，
	如不间断的对角线或斜线。Johnson[13]使用Karpand Rabin[14]基于指纹的高效字符串匹配。
	
- 令牌比较

  是一种线性的比较。不用字符串比较，而是通过后缀树有效地比较行的标记序列。

  首先，整行的每个标记序列由一个所谓的函子总结，函子从标识符和文字的具体值中抽象出来[1]。函子唯一地刻画了这个标记序列。赋值函子可以看作是一个完美的散列函数。标识符和文字的具体值被捕获为这个函子的参数。这些参数的编码是从它们的具体值中提取出来的，而不是从它们的顺序中提取出来的，这样就可以检测到只在参数的系统重命名中不同的代码片段。如果两行的函子和参数编码匹配，那么它们就是克隆。

  函子及其参数汇总在后缀树中，后缀树以紧凑的方式表示程序的所有后缀。后缀树可以建立在时间和空间线性输入长度[7]，[15]。后缀树中的每一个分支都表示程序后缀，它们的开头都是相同的克隆序列。

- 度量比较

	收集代码片段的不同度量并比较这些度量向量，而不是直接比较代码。这些度量向量的允许距离（例如，欧几里德距离）可以用作类似度量的提示代码。（网站中使用较多）
	
- 抽象语法树的比较

  Baxter等人。基于哈希函数划分程序抽象语法树的子树，然后通过树匹配比较同一分区中的子树（允许一些差异）[8]。Yang[22]早期提出了一种类似的方法，使用动态规划来发现同一文件的两个版本之间的差异。

- 程序依赖图（PDG）的比较。
	函数的控制和数据流依赖关系可以用程序依赖图来表示；克隆可以被识别为同构子图[10]，[11]；因为这个问题是NP-hard的，Krinke 使用近似解。
  
- 其他技术。

  Marcus和 Maletic 使用潜在语义索引（一种信息检索技术）来识别出现相似名称的片段[23]。
  Leitao[24]通过组合专门的比较函数（类似的调用子图、交换运算符、用户定义的等价关系以及转换为规范的语法形式）
  将句法和语义技术结合起来。每个比较函数都会产生一个证据，该证据在一个产生克隆可能性的证据因子模型中汇总。
  Wauler-等人（25）和Li等人（26）将相似的片段搜索作为数据挖掘问题。语句序列汇总到项集。
  一种自适应的数据挖掘算法搜索频繁项集。

### section 3

主要是一些相关的定义

- what is clone？

  粗略地说，根据给定的相似性定义，如果两个代码片段足够相似，就形成一个克隆对。不同的相似性定义和相关的容忍度允许不同种类和程度的克隆。如果B包含A的功能，那么一段代码A与另一段代码B相似；换句话说，它们具有“相似”的前提条件和后置条件。我们把这样的一对称为（A，B）语义克隆。不幸的是，检测语义克隆通常是不确定的。

  另一个定义：

  相似性的另一个定义是考虑程序文本：如果两个代码片段的程序文本相似，它们就形成一个克隆对。这两个代码片段在语义上可能等价，也可能不等价。这类克隆通常是复制粘贴的结果，也就是说，程序员选择一个代码片段并将其复制到另一个代码片段位置。复制和粘贴是一种常见的编程实践，也是特别重用的一个例子。本实验所评估的自动克隆检测仪发现了程序文本中相似的克隆，因此本文采用了克隆对的后一种定义。

-  关于克隆程度的相关定义

  类型1是没有修改的精确副本（空白和注释除外）。

  类型2是语法上相同的副本；只更改了变量、类型或函数标识符。

  类型3是经过进一步修改的副本；状态更改、添加或删除。

  相关定义

  **定义1**.克隆（对）是三元组（f1；f2；t），其中f1和f2是两个相似的代码片段，t是相关的相似类型（类型1、2或3）。

  **定义2**.代码片段是一个元组（f；s；e），它由源文件的名称f、片段的起始行s和结束行e组成。两个行号都包含在内

### section 4

主要讲述了他们实验的设置

**定义3**.重叠是共同代码与两个代码片段（CF1和CF2）的比率，即它们的交集与其并集相关。让行（CF）表示代码片段CF的行集合；然后，重叠（CF1；CF2）定义为：

![image-20210402161602857](C:\Users\60917\AppData\Roaming\Typora\typora-user-images\image-20210402161602857.png)

**定义4**.包含是一个代码片段的代码与另一个代码片段的代码之比。让行（CF1）表示第一个代码片段的行集合，行（CF2）表示第二个代码片段的行集合；然后，包含的（CF1；CF2）定义为：

![image-20210402165849978](C:\Users\60917\AppData\Roaming\Typora\typora-user-images\image-20210402165849978.png)

关于CF1<CF2的定义，CF1的文件名小于CF2的文件名，或者说尽管两者的文件名相等但是CF1的开始行小于CF2的开始行，或者说在文件名与开始行相等的情况下，CF1的结束行小于CF2的结束行

![image-20210402163000617](C:\Users\60917\AppData\Roaming\Typora\typora-user-images\image-20210402163000617.png)

**定义5**.两个克隆对CP1和CP2之间的良好值定义如下

![image-20210402165743125](C:\Users\60917\AppData\Roaming\Typora\typora-user-images\image-20210402165743125.png)

两个克隆对CP1和CP2满足以下条件，存在p∈[0，1]使得

![img](file:///C:/Users/60917/AppData/Local/Temp/msohtmlclip1/01/clip_image002.png)

成立，则称CP1和CP2是好匹配（p）-->原文标识good-match（p）

我们使用最小重叠度，因为它比最大重叠度或平均重叠度更严格。

**定义6**.两个克隆对CP1和CP2之间的OK值定义如下

![img](file:///C:/Users/60917/AppData/Local/Temp/msohtmlclip1/01/clip_image001.png)

![img](file:///C:/Users/60917/AppData/Local/Temp/msohtmlclip1/01/clip_image002.png)



### section 5

主要讲述了他们实验的结果

### section 6

主要是将他们的研究与其他的实验结果相联系。

### section 7

主要是得出一些相关的结论



## 下周期望
1、继续阅读论文《Comparison and Evaluation of Clone Detection Tools》。

2、尽量实现其中的代码部分。